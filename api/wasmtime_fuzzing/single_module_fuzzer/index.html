<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Support for maintaining the usefulness of a corpus over time."><title>wasmtime_fuzzing::single_module_fuzzer - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-a23c9d150ad85d8b.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="wasmtime_fuzzing" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.0-nightly (6162f6f12 2023-07-01)" data-channel="nightly" data-search-js="search-91b58767224854cb.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ><script src="../../static.files/storage-59fd9b8ccb335783.js"></script><script defer src="../../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../wasmtime_fuzzing/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../wasmtime_fuzzing/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module single_module_fuzzer</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">wasmtime_fuzzing</a>::<wbr><a class="mod" href="#">single_module_fuzzer</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../src/wasmtime_fuzzing/single_module_fuzzer.rs.html#1-337">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Support for maintaining the usefulness of a corpus over time.</p>
<p>Wasmtime’s fuzzing strategy in general is to use <code>wasm-smith</code> to generate
modules which interprets fuzz input from libFuzzer as a sort of “DNA”. This
works to generate pretty interesting modules but falls down over time
because the DNA to generate the same module over time can change. This
means that maintaining a corpus for Wasmtime is not the most useful thing
in the world unfortunately and any historical discoveries of coverage need
to be rediscovered every time the DNA changes.</p>
<p>To help with this the module here implements a scheme where Wasmtime’s fuzz
inputs are highly likely to be of the form:</p>
<div class="example-wrap"><pre class="language-text"><code>[ ... wasm module ... ][ .. fuzz custom section .. ]
</code></pre></div>
<p>The <code>fuzz custom section</code> here contains the original fuzz input used to
generate the <code>wasm module</code>, and if the DNA hasn’t changed then it should
still be possible to do that as well. The benefit of this format, though,
is that if the DNA is changed then the interpretation of the <code>fuzz custom section</code> will change but the original <code>wasm module</code> will not. This enables
us to populate the corpus, ideally, with a set of interesting <code>wasm module</code>
entries.</p>
<p>Over time the <code>fuzz custom section</code> will “bitrot” and will be no longer able
to generate the original <code>wasm module</code>. The main consequence of this is that
when the original test case is mutated the generated wasm module from the
mutation will be nothing alike from the original test case’s wasm module.
This means libFuzzer will have to rediscover ways to mutate into
interesting modules, but we’re no worse off than before hopefully.
Additionally this more easily opens the door to integrate <code>wasm-mutate</code> one
day into mutation here as well.</p>
<p>Currently this is all supported via two methods:</p>
<ol>
<li>
<p>A custom mutator is registered with libfuzzer. This means that all
inputs generated by the mutator, so long as they fit, will be the
“envelope” format of this module. This means that the corpus will
hopefully naturally get populated with wasm files rather than random
inputs. Note that this is not guaranteed to succeed since sometimes the
buffer to store the fuzz input in the mutator is not big enough to store
the final wasm module, in which case a non-enveloped wasm module is
stored.</p>
</li>
<li>
<p>If the environment variable `WRITE_FUZZ_INPUT_TO is set then the fuzz
input, in its envelope format, will be written to the specified file.
This can be useful in case an input is in its binary form or if a
preexisting corpus is being rewritten.</p>
</li>
</ol>
</div></details><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.execute.html" title="fn wasmtime_fuzzing::single_module_fuzzer::execute">execute</a></div><div class="desc docblock-short">Executes a “single module fuzzer” given the raw <code>input</code> from libfuzzer.</div></li><li><div class="item-name"><a class="fn" href="fn.mutate.html" title="fn wasmtime_fuzzing::single_module_fuzzer::mutate">mutate</a></div><div class="desc docblock-short">Implementation of a libfuzzer custom mutator for a single-module-fuzzer.</div></li></ul></section></div></main></body></html>